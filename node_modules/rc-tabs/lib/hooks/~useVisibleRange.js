"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = useVisibleRange;

var _react = require("react");

var DEFAULT_SIZE = {
  width: 0,
  height: 0,
  left: 0,
  top: 0,
  right: 0
};
/**
 * Calculate what range of tabs is fully visible
 * @param tabOffsets Each Tab bounding rect info
 * @param containerSizeInfo Full outer container size (includes tabs, extra, operation, etc.)
 * @param tabContentNodeSizeInfo Size of full tabs
 * @param addNodeSizeInfo Size of addNode only
 * @param operationNodeSizeInfo Size of operation node (includes addNode & dropdown)
 * @param tabInfo
 * @returns
 */

function useVisibleRange(tabOffsets, containerSizeInfo, tabContentNodeSizeInfo, addNodeSizeInfo, operationNodeSizeInfo, _ref) {
  var tabs = _ref.tabs,
      tabPosition = _ref.tabPosition,
      rtl = _ref.rtl;
  var unit;
  var charUnit;
  var position;
  var transformSize;

  if (['top', 'bottom'].includes(tabPosition)) {
    unit = 0;
    charUnit = 'width';
    position = rtl ? 'right' : 'left';
    transformSize = Math.abs(containerSizeInfo[2]);
  } else {
    unit = 1;
    charUnit = 'height';
    position = 'top';
    transformSize = -containerSizeInfo[3];
  }

  var containerSize = containerSizeInfo[unit];
  var tabContentSize = tabContentNodeSizeInfo[unit];
  var addNodeSize = addNodeSizeInfo[unit];
  var operationNodeSize = operationNodeSizeInfo[unit];
  return (0, _react.useMemo)(function () {
    if (!tabs.length) {
      return [0, 0, containerSize];
    } // Check if we can put all without scrollable


    var needScroll = containerSize < tabContentSize + addNodeSize;
    var visibleTabContentSize = needScroll ? containerSize - operationNodeSize : containerSize - addNodeSize;
    var len = tabs.length;
    var endIndex = len;

    for (var i = 0; i < len; i += 1) {
      var offset = tabOffsets.get(tabs[i].key) || DEFAULT_SIZE;

      if (offset[position] + offset[charUnit] > transformSize + visibleTabContentSize) {
        endIndex = i - 1;
        break;
      }
    }

    var startIndex = 0;

    for (var _i = len - 1; _i >= 0; _i -= 1) {
      var _offset = tabOffsets.get(tabs[_i].key) || DEFAULT_SIZE;

      if (_offset[position] < transformSize) {
        startIndex = _i + 1;
        break;
      }
    }

    return [startIndex, endIndex, visibleTabContentSize];
  }, [tabOffsets, containerSize, tabContentSize, addNodeSize, operationNodeSize, transformSize, tabPosition, tabs.map(function (tab) {
    return tab.key;
  }).join('_'), rtl]);
}